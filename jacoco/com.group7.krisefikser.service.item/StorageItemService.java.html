<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StorageItemService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">krisefikser</a> &gt; <a href="index.source.html" class="el_package">com.group7.krisefikser.service.item</a> &gt; <span class="el_source">StorageItemService.java</span></div><h1>StorageItemService.java</h1><pre class="source lang-java linenums">package com.group7.krisefikser.service.item;

import static java.util.stream.Collectors.toList;

import com.group7.krisefikser.dto.request.item.ChangeStorageItemSharedStatusRequest;
import com.group7.krisefikser.dto.request.item.StorageItemRequest;
import com.group7.krisefikser.dto.request.item.StorageItemSortRequest;
import com.group7.krisefikser.dto.response.item.AggregatedStorageItemResponse;
import com.group7.krisefikser.dto.response.item.ItemResponse;
import com.group7.krisefikser.dto.response.item.StorageItemGroupResponse;
import com.group7.krisefikser.dto.response.item.StorageItemResponse;
import com.group7.krisefikser.enums.ItemType;
import com.group7.krisefikser.model.household.Household;
import com.group7.krisefikser.model.item.Item;
import com.group7.krisefikser.model.item.StorageItem;
import com.group7.krisefikser.repository.household.HouseholdRepository;
import com.group7.krisefikser.repository.item.ItemRepo;
import com.group7.krisefikser.repository.item.StorageItemRepo;
import com.group7.krisefikser.service.household.HouseholdService;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * This class is a service for managing storage items.
 * It provides methods to get, add, update, delete, sort and filter storage items.
 * It uses StorageItemRepo to interact with the database.
 */
@Service
@RequiredArgsConstructor
public class StorageItemService {
  private final StorageItemRepo storageItemRepo;
  private final ItemRepo itemRepo;
  private final HouseholdService householdService;
  private final HouseholdRepository householdRepository;
  private final ItemService itemService;
<span class="fc" id="L46">  private static final Logger logger = Logger.getLogger(StorageItemService.class.getName());</span>


  /**
   * Retrieves all storage items for a specific household from the repository.
   *
   * @param householdId The ID of the household to retrieve storage items for.
   * @return A list of all storage items available for the specified household.
   */
  public List&lt;StorageItem&gt; getAllStorageItems(int householdId) {
<span class="fc" id="L56">    return storageItemRepo.getAllStorageItems(householdId);</span>
  }

  /**
   * Retrieves all shared storage items for a specific group from the repository.
   * Using the group ID for the current user, it fetches all storage items that are
   * marked as shared.
   *
   * @return A list of all shared storage items available for the specified group.
   */
  public List&lt;AggregatedStorageItemResponse&gt; getSharedStorageItemsInGroup(
          List&lt;String&gt; itemTypesString,
          StorageItemSortRequest sortRequest) {
<span class="fc" id="L69">    List&lt;ItemType&gt; itemTypes = itemService.convertToItemTypes(itemTypesString);</span>
<span class="fc" id="L70">    long groupId = householdService.getGroupIdForCurrentUser();</span>
<span class="fc" id="L71">    List&lt;StorageItem&gt; storageItems = storageItemRepo.getAllSharedStorageItemsInGroup(groupId);</span>

<span class="fc" id="L73">    List&lt;AggregatedStorageItemResponse&gt; aggregatedItems =</span>
<span class="fc" id="L74">            aggregateStorageItems(storageItems, null, null);</span>

<span class="fc" id="L76">    return filterAndSortAggregatedStorageItems(</span>
            aggregatedItems,
            itemTypes,
<span class="fc" id="L79">            sortRequest.getSortBy(),</span>
<span class="fc" id="L80">            sortRequest.getSortDirection()</span>
    );
  }

  /**
   * Retrieves storage items by their item ID for a specific household.
   *
   * @param itemId      The item ID of the storage items to retrieve.
   * @param householdId The ID of the household the storage items belong to.
   * @return A list of storage items of the specified item.
   */
  public List&lt;StorageItem&gt; getStorageItemsByItemId(int itemId, int householdId) {
<span class="fc" id="L92">    return storageItemRepo.findByItemId(itemId, householdId);</span>
  }

  /**
   * Retrieves all storage items for a specific group ID and item ID.
   *
   * @param itemId The itemID of the items to retrieve.
   * @return The storage item with the specified ID, or null if not found.
   */
  public List&lt;StorageItemGroupResponse&gt; getSharedStorageItemsInGroupByItemId(
          int itemId) {
<span class="fc" id="L103">    Long groupId = householdService.getGroupIdForCurrentUser();</span>

<span class="fc" id="L105">    List&lt;StorageItem&gt; storageItems = storageItemRepo</span>
<span class="fc" id="L106">            .getSharedStorageItemsInGroupByItemId(groupId, itemId);</span>


<span class="fc" id="L109">    return storageItems.stream()</span>
<span class="fc" id="L110">            .map(storageItem -&gt; new StorageItemGroupResponse(</span>
<span class="fc" id="L111">                    convertToStorageItemResponse(storageItem),</span>
<span class="fc" id="L112">                    householdService.getHouseholdNameById((long) storageItem.getHouseholdId())</span>
            ))
<span class="fc" id="L114">            .toList();</span>
  }


  /**
   * Adds a new storage item to the repository after validating it.
   * This method ensures that the item meets all validation criteria
   * before delegating the addition to the repository.
   *
   * @param storageItem The storage item to be added.
   * @return The added storage item with its generated ID.
   */
  public StorageItem addStorageItem(StorageItem storageItem) {
<span class="fc" id="L127">    validateStorageItem(storageItem);</span>

    // Ensure the referenced item exists
<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (!itemExists(storageItem.getItemId())) {</span>
<span class="fc" id="L131">      throw new RuntimeException(&quot;Item not found with id: &quot; + storageItem.getItemId());</span>
    }

<span class="fc" id="L134">    return storageItemRepo.add(storageItem);</span>
  }

  /**
   * Updates an existing storage item in the repository after validating it.
   * This method ensures that the item meets all validation criteria
   * before delegating the update to the repository.
   *
   * @param id          The ID of the storage item to be updated.
   * @param householdId The ID of the household the storage item belongs to.
   * @param storageItem The updated storage item details.
   * @return The updated storage item.
   */
  public StorageItem updateStorageItem(int id, int householdId, StorageItem storageItem) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (!storageItemExists(id, householdId)) {</span>
<span class="nc" id="L149">      throw new RuntimeException(&quot;Storage item not found with id: &quot; + id</span>
              + &quot; in household: &quot; + householdId);
    }

<span class="fc" id="L153">    validateStorageItem(storageItem);</span>

    // Ensure the referenced item exists
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">    if (!itemExists(storageItem.getItemId())) {</span>
<span class="nc" id="L157">      throw new RuntimeException(&quot;Item not found with id: &quot; + storageItem.getItemId());</span>
    }

    // Ensure household ID is not changed
<span class="fc" id="L161">    storageItem.setId(id);</span>
<span class="fc" id="L162">    storageItem.setHouseholdId(householdId);</span>
<span class="fc" id="L163">    return storageItemRepo.update(storageItem);</span>
  }

  /**
   * Updates a shared storage item from the request.
   * This method checks if the item is shared and if the user belongs to the same group
   * before allowing the update.
   *
   * @param id      The ID of the storage item to be updated.
   * @param request The request containing the updated storage item details.
   * @return The updated storage item response.
   */
  public StorageItemResponse updateSharedStorageItem(int id,
                                                     StorageItemRequest request) {

<span class="fc" id="L178">    Long userGroupId = householdService.getGroupIdForCurrentUser();</span>
<span class="fc" id="L179">    StorageItem existingItem = storageItemRepo.findById(id).orElseThrow(</span>
<span class="fc" id="L180">        () -&gt; new NoSuchElementException(&quot;Storage item not found with id: &quot; + id)</span>
    );

<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (!existingItem.isShared()) {</span>
<span class="fc" id="L184">      throw new IllegalArgumentException(&quot;Item is not shared, user is not allowed to &quot;</span>
        + &quot;update&quot;);
    }

<span class="fc" id="L188">    Household household = householdRepository.getHouseholdById((long) existingItem.getHouseholdId())</span>
<span class="pc" id="L189">        .orElseThrow(() -&gt; new NoSuchElementException(&quot;Household not found with id: &quot;</span>
<span class="nc" id="L190">        + existingItem.getHouseholdId()));</span>

<span class="pc bpc" id="L192" title="1 of 2 branches missed.">    if (!household.getEmergencyGroupId().equals(userGroupId)) {</span>
<span class="nc" id="L193">      throw new IllegalArgumentException(&quot;User is not allowed to update this item&quot;);</span>
    }

<span class="fc" id="L196">    StorageItem updatedItem = request.updateExistingEntity(existingItem);</span>

<span class="fc" id="L198">    validateStorageItem(updatedItem);</span>

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">    if (!itemExists(updatedItem.getItemId())) {</span>
<span class="nc" id="L201">      throw new RuntimeException(&quot;Item not found with id: &quot; + updatedItem.getItemId());</span>
    }

<span class="fc" id="L204">    StorageItem result = storageItemRepo.update(updatedItem);</span>
<span class="fc" id="L205">    return convertToStorageItemResponse(result);</span>
  }

  /**
   * Deletes a storage item from the repository by its ID.
   *
   * @param id          The ID of the storage item to be deleted.
   * @param householdId The ID of the household the storage item belongs to.
   */
  public void deleteStorageItem(int id, int householdId) {
<span class="fc" id="L215">    Long groupId = householdService.getGroupIdForCurrentUser();</span>
<span class="fc" id="L216">    StorageItem storageItem = storageItemRepo.findById(id)</span>
<span class="fc" id="L217">                    .orElseThrow(() -&gt; new NoSuchElementException(</span>
                    &quot;Storage item not found with id: &quot; + id));
<span class="fc" id="L219">    Household household = householdRepository.getHouseholdById((long) householdId)</span>
<span class="pc" id="L220">            .orElseThrow(() -&gt; new RuntimeException(&quot;Household not found with id: &quot;</span>
                    + householdId));

<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (storageItem.getHouseholdId() != householdId</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            &amp;&amp; (!Objects.equals(groupId, household.getEmergencyGroupId())</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                || !storageItem.isShared())) {</span>
<span class="fc" id="L226">      throw new IllegalArgumentException(&quot;User is not allowed to delete this item&quot;);</span>
    }

<span class="fc" id="L229">    storageItemRepo.deleteById(id, householdId);</span>
<span class="fc" id="L230">  }</span>

  /**
   * Retrieves storage items that are about to expire for a specific household.
   *
   * @param days        The number of days within which items will expire.
   * @param householdId The ID of the household to retrieve expiring items for.
   * @return A list of storage items that will expire within the specified number of days.
   */
  public List&lt;StorageItem&gt; getExpiringStorageItems(int days, int householdId) {
<span class="fc" id="L240">    return storageItemRepo.findExpiringItems(days, householdId);</span>
  }

  /**
   * Validates the storage item properties before adding or updating it.
   * This method checks if the expiration date, quantity, household ID, and item ID are valid.
   *
   * @param storageItem The storage item to be validated.
   */
  private void validateStorageItem(StorageItem storageItem) {
    // Expiration date validation
<span class="fc bfc" id="L251" title="All 2 branches covered.">    if (storageItem.getExpirationDate() == null) {</span>
<span class="fc" id="L252">      throw new IllegalArgumentException(&quot;Expiration date cannot be null&quot;);</span>
    }

    // Quantity validation
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    if (storageItem.getQuantity() &lt; 0) {</span>
<span class="nc" id="L257">      throw new IllegalArgumentException(&quot;Quantity cannot be negative&quot;);</span>
    }

    // Household ID validation
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    if (storageItem.getHouseholdId() &lt;= 0) {</span>
<span class="nc" id="L262">      throw new IllegalArgumentException(&quot;Invalid household ID&quot;);</span>
    }

    // Item ID validation
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">    if (storageItem.getItemId() &lt;= 0) {</span>
<span class="nc" id="L267">      throw new IllegalArgumentException(&quot;Invalid item ID&quot;);</span>
    }
<span class="fc" id="L269">  }</span>

  /**
   * Checks if a storage item exists in the repository by its ID for a specific household.
   *
   * @param id          The ID of the storage item to check.
   * @param householdId The ID of the household the storage item belongs to.
   * @return true if the storage item exists, false otherwise.
   */
  public boolean storageItemExists(int id, int householdId) {
<span class="fc" id="L279">    return storageItemRepo.findById(id).isPresent();</span>
  }

  /**
   * Checks if an item exists in the repository by its ID.
   *
   * @param id The ID of the item to check.
   * @return true if the item exists, false otherwise.
   */
  private boolean itemExists(int id) {
<span class="fc" id="L289">    return itemRepo.findById(id).isPresent();</span>
  }

  /**
   * Converts a single StorageItem entity to a StorageItemResponse DTO with item details.
   *
   * @param storageItem The StorageItem entity
   * @return A StorageItemResponse with item details
   */
  public StorageItemResponse convertToStorageItemResponse(StorageItem storageItem) {
    try {
<span class="fc" id="L300">      Item item = itemRepo.findById(storageItem.getItemId()).orElse(null);</span>
<span class="fc" id="L301">      ItemResponse itemResponse = null;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">      if (item != null) {</span>
<span class="fc" id="L303">        itemResponse = ItemResponse.fromEntity(item);</span>
      }
<span class="fc" id="L305">      return StorageItemResponse.fromEntityWithItem(storageItem, itemResponse);</span>
<span class="nc" id="L306">    } catch (Exception e) {</span>
<span class="nc" id="L307">      return StorageItemResponse.fromEntity(storageItem);</span>
    }
  }

  /**
   * Converts a list of StorageItem entities to StorageItemResponse DTOs.
   *
   * @param storageItems The list of StorageItem entities
   * @return A list of StorageItemResponse DTOs
   */
  public List&lt;StorageItemResponse&gt; convertToStorageItemResponses(List&lt;StorageItem&gt; storageItems) {
<span class="fc" id="L318">    return storageItems.stream()</span>
<span class="fc" id="L319">            .map(this::convertToStorageItemResponse)</span>
<span class="fc" id="L320">            .toList();</span>
  }

  /**
   * Adds a new storage item based on the provided request DTO.
   *
   * @param householdId The household ID to assign to the new storage item
   * @param request     The request containing the storage item details
   * @return The response DTO for the created storage item
   */
  public StorageItemResponse addStorageItemFromRequest(int householdId,
                                                       StorageItemRequest request) {
<span class="nc" id="L332">    StorageItem storageItem = request.toEntity();</span>
<span class="nc" id="L333">    storageItem.setHouseholdId(householdId);</span>
<span class="nc" id="L334">    StorageItem createdStorageItem = addStorageItem(storageItem);</span>
<span class="nc" id="L335">    return convertToStorageItemResponse(createdStorageItem);</span>
  }

  /**
   * Updates an existing storage item based on the provided request DTO.
   *
   * @param id          The ID of the storage item to update
   * @param householdId The household ID the storage item belongs to
   * @param request     The request containing the updated storage item details
   * @return The response DTO for the updated storage item
   */
  public StorageItemResponse updateStorageItemFromRequest(int id, int householdId,
                                                          StorageItemRequest request) {
<span class="nc" id="L348">    StorageItem storageItem = request.toEntity();</span>
<span class="nc" id="L349">    storageItem.setId(id);</span>
<span class="nc" id="L350">    storageItem.setHouseholdId(householdId);</span>
<span class="nc" id="L351">    StorageItem updatedStorageItem = updateStorageItem(id, householdId, storageItem);</span>
<span class="nc" id="L352">    return convertToStorageItemResponse(updatedStorageItem);</span>
  }

  /**
   * Aggregates storage items by item ID for a specific household.
   *
   * @param householdId The ID of the household
   * @return A list of aggregated storage item responses
   */
  public List&lt;AggregatedStorageItemResponse&gt; getAggregatedStorageItems(int householdId) {
<span class="fc" id="L362">    return getAggregatedStorageItems(householdId, null, null);</span>
  }

  /**
   * Aggregates storage items by item ID for a specific household,
   * with optional sorting.
   *
   * @param householdId   The ID of the household
   * @param sortBy        The field to sort by (e.g., &quot;quantity&quot;, &quot;expirationDate&quot;, &quot;name&quot;)
   * @param sortDirection The direction of sorting (e.g., &quot;asc&quot; or &quot;desc&quot;)
   * @return A list of aggregated storage item responses
   */
  public List&lt;AggregatedStorageItemResponse&gt; getAggregatedStorageItems(
          int householdId,
          String sortBy,
          String sortDirection) {
<span class="fc" id="L378">    List&lt;StorageItem&gt; allItems = storageItemRepo.getAllStorageItems(householdId);</span>

<span class="fc" id="L380">    return aggregateStorageItems(allItems, sortBy, sortDirection);</span>
  }

  /**
   * Aggregates storage items by item ID and creates a list of aggregated responses.
   *
   * @param storageItems  The list of all storage items
   * @param sortBy        The field to sort by (e.g., &quot;quantity&quot;, &quot;expirationDate&quot;, &quot;name&quot;)
   * @param sortDirection The direction of sorting (e.g., &quot;asc&quot; or &quot;desc&quot;)
   * @return A list of aggregated storage item responses
   */
  public List&lt;AggregatedStorageItemResponse&gt; aggregateStorageItems(
          List&lt;StorageItem&gt; storageItems,
          String sortBy,
          String sortDirection) {
<span class="fc" id="L395">    Map&lt;Integer, List&lt;StorageItem&gt;&gt; groupedByItemId = storageItems.stream()</span>
<span class="fc" id="L396">            .collect(Collectors.groupingBy(StorageItem::getItemId));</span>

    // Create aggregated responses
<span class="fc" id="L399">    List&lt;AggregatedStorageItemResponse&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">    for (Map.Entry&lt;Integer, List&lt;StorageItem&gt;&gt; entry : groupedByItemId.entrySet()) {</span>
<span class="fc" id="L402">      int itemId = entry.getKey();</span>
<span class="fc" id="L403">      List&lt;StorageItem&gt; items = entry.getValue();</span>

      // Calculate total quantity
<span class="fc" id="L406">      double totalQuantity = items.stream()</span>
<span class="fc" id="L407">              .mapToDouble(StorageItem::getQuantity)</span>
<span class="fc" id="L408">              .sum();</span>

      // Find earliest expiration date
<span class="fc" id="L411">      LocalDateTime earliestDate = items.stream()</span>
<span class="fc" id="L412">              .map(StorageItem::getExpirationDate)</span>
<span class="fc" id="L413">              .min(LocalDateTime::compareTo)</span>
<span class="fc" id="L414">              .orElse(null);</span>

      // Get item details
<span class="fc" id="L417">      Item item = null;</span>
      try {
<span class="fc" id="L419">        item = itemRepo.findById(itemId).orElse(null);</span>
<span class="nc" id="L420">      } catch (Exception e) {</span>
        // Log error but continue processing
<span class="nc" id="L422">        logger.warning(&quot;Could not fetch item with ID &quot; + itemId + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L423">      }</span>

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">      ItemResponse itemResponse = item != null ? ItemResponse.fromEntity(item) : null;</span>

      // Create the aggregated response
<span class="fc" id="L428">      AggregatedStorageItemResponse aggregated = new AggregatedStorageItemResponse(</span>
              itemId,
              itemResponse,
              totalQuantity,
              earliestDate
      );

<span class="fc" id="L435">      result.add(aggregated);</span>
<span class="fc" id="L436">    }</span>

    // Apply sorting if provided
<span class="pc bpc" id="L439" title="3 of 4 branches missed.">    if (sortBy != null &amp;&amp; !sortBy.isEmpty()) {</span>
<span class="nc" id="L440">      Comparator&lt;AggregatedStorageItemResponse&gt; comparator =</span>
<span class="nc" id="L441">              createAggregatedComparator(sortBy, sortDirection);</span>
<span class="nc" id="L442">      result.sort(comparator);</span>
    }

<span class="fc" id="L445">    return result;</span>
  }

  /**
   * Creates a comparator for sorting aggregated storage items.
   *
   * @param sortBy        The field to sort by
   * @param sortDirection The direction of sorting
   * @return A comparator for sorting aggregated storage items
   */
  private Comparator&lt;AggregatedStorageItemResponse&gt; createAggregatedComparator(
          String sortBy, String sortDirection) {
<span class="pc bpc" id="L457" title="3 of 4 branches missed.">    Comparator&lt;AggregatedStorageItemResponse&gt; comparator = switch (sortBy.toLowerCase()) {</span>
<span class="fc" id="L458">      case &quot;quantity&quot; -&gt; Comparator.comparing(AggregatedStorageItemResponse::getTotalQuantity);</span>
<span class="nc" id="L459">      case &quot;expirationdate&quot; -&gt; Comparator.comparing(</span>
              AggregatedStorageItemResponse::getEarliestExpirationDate,
<span class="nc" id="L461">              Comparator.nullsLast(Comparator.naturalOrder())</span>
      );
<span class="nc" id="L463">      case &quot;name&quot; -&gt; Comparator.comparing(</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">              response -&gt; response.getItem() != null ? response.getItem().getName() : &quot;&quot;,</span>
              String.CASE_INSENSITIVE_ORDER
      );
<span class="pc" id="L467">      default -&gt; Comparator.comparing(AggregatedStorageItemResponse::getItemId);</span>
    };

<span class="pc bpc" id="L470" title="1 of 2 branches missed.">    return &quot;desc&quot;.equalsIgnoreCase(sortDirection) ? comparator.reversed() : comparator;</span>
  }

  /**
   * Aggregates storage items by item ID for a specific household,
   * with optional filtering and sorting.
   *
   * @param householdId   The ID of the household
   * @param itemTypes     The item types to filter by
   * @param sortBy        The field to sort by
   * @param sortDirection The direction of sorting
   * @return A list of filtered and sorted aggregated storage item responses
   */
  public List&lt;AggregatedStorageItemResponse&gt; getFilteredAndSortedAggregatedItems(
          int householdId,
          List&lt;ItemType&gt; itemTypes,
          String sortBy,
          String sortDirection) {

    // Get aggregated items
<span class="fc" id="L490">    List&lt;AggregatedStorageItemResponse&gt; aggregatedItems =</span>
<span class="fc" id="L491">            getAggregatedStorageItems(householdId, null, null);</span>


<span class="fc" id="L494">    return filterAndSortAggregatedStorageItems(</span>
            aggregatedItems,
            itemTypes,
            sortBy,
            sortDirection
    );
  }

  private List&lt;AggregatedStorageItemResponse&gt; filterAndSortAggregatedStorageItems(
          List&lt;AggregatedStorageItemResponse&gt; aggregatedItems,
          List&lt;ItemType&gt; itemTypes,
          String sortBy,
          String sortDirection) {

<span class="fc" id="L508">    List&lt;AggregatedStorageItemResponse&gt; filteredItems = aggregatedItems;</span>
<span class="pc bpc" id="L509" title="1 of 4 branches missed.">    if (itemTypes != null &amp;&amp; !itemTypes.isEmpty()) {</span>
<span class="fc" id="L510">      filteredItems = aggregatedItems.stream()</span>
<span class="fc" id="L511">              .filter(aggregated -&gt;</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">                      aggregated.getItem() != null</span>
                              &amp;&amp;
<span class="fc bfc" id="L514" title="All 2 branches covered.">                              itemTypes.contains(aggregated.getItem().getType()))</span>
<span class="fc" id="L515">              .collect(toList());</span>
    }

    // Apply sorting if provided
<span class="pc bpc" id="L519" title="2 of 4 branches missed.">    if (sortBy != null &amp;&amp; !sortBy.isEmpty()) {</span>
<span class="fc" id="L520">      Comparator&lt;AggregatedStorageItemResponse&gt; comparator =</span>
<span class="fc" id="L521">              createAggregatedComparator(sortBy, sortDirection);</span>
<span class="fc" id="L522">      filteredItems.sort(comparator);</span>
    }

<span class="fc" id="L525">    return filteredItems;</span>
  }

  /**
   * Searches for aggregated storage items by item name and/or type.
   *
   * @param householdId   The ID of the household
   * @param searchTerm    The search term to match against item names (can be null)
   * @param itemTypes     The item types to filter by (can be null or empty)
   * @param sortBy        The field to sort by (can be null)
   * @param sortDirection The direction of sorting (can be null)
   * @return A list of matching aggregated storage item responses
   */
  public List&lt;AggregatedStorageItemResponse&gt; searchAggregatedStorageItems(
          int householdId,
          String searchTerm,
          List&lt;ItemType&gt; itemTypes,
          String sortBy,
          String sortDirection) {

    // Get all aggregated items for this household
<span class="fc" id="L546">    List&lt;AggregatedStorageItemResponse&gt; allItems = getAggregatedStorageItems(householdId);</span>

    // Apply filtering based on search term and item types
<span class="fc" id="L549">    List&lt;AggregatedStorageItemResponse&gt; filteredItems = allItems.stream()</span>
<span class="fc" id="L550">            .filter(item -&gt; {</span>
<span class="fc" id="L551">              boolean matchesSearchTerm = true;</span>
<span class="fc" id="L552">              boolean matchesItemType = true;</span>

              // Filter by search term if provided (case-insensitive partial match)
<span class="pc bpc" id="L555" title="3 of 6 branches missed.">              if (searchTerm != null &amp;&amp; !searchTerm.trim().isEmpty() &amp;&amp; item.getItem() != null) {</span>
<span class="fc" id="L556">                matchesSearchTerm = item.getItem().getName().toLowerCase()</span>
<span class="fc" id="L557">                        .contains(searchTerm.toLowerCase().trim());</span>
              }

              // Filter by item types if provided
<span class="pc bpc" id="L561" title="3 of 6 branches missed.">              if (itemTypes != null &amp;&amp; !itemTypes.isEmpty() &amp;&amp; item.getItem() != null) {</span>
<span class="fc" id="L562">                matchesItemType = itemTypes.contains(item.getItem().getType());</span>
              }

<span class="fc bfc" id="L565" title="All 4 branches covered.">              return matchesSearchTerm &amp;&amp; matchesItemType;</span>
            })
<span class="fc" id="L567">            .collect(toList());</span>

    // Apply sorting if provided
<span class="pc bpc" id="L570" title="3 of 4 branches missed.">    if (sortBy != null &amp;&amp; !sortBy.isEmpty()) {</span>
<span class="nc" id="L571">      Comparator&lt;AggregatedStorageItemResponse&gt; comparator =</span>
<span class="nc" id="L572">              createAggregatedComparator(sortBy, sortDirection);</span>
<span class="nc" id="L573">      filteredItems.sort(comparator);</span>
    }
<span class="fc" id="L575">    return filteredItems;</span>
  }

  /**
   * Changes the shared status of a storage item and updates its quantity.
   * If the quantity is changed, a new storage item is created with the updated quantity.
   *
   * @param id      The ID of the storage item to update
   * @param request The request containing the new shared status and quantity
   * @return A list of updated storage item responses
   */
  @Transactional
  public List&lt;StorageItemResponse&gt; updateStorageItemSharedStatus(
          int id, long householdId, ChangeStorageItemSharedStatusRequest request) {
<span class="fc" id="L589">    StorageItem storageItem = storageItemRepo.findById(id).orElseThrow(</span>
<span class="fc" id="L590">            () -&gt; new NoSuchElementException(&quot;Storage item not found with id: &quot; + id)</span>
    );
<span class="fc bfc" id="L592" title="All 2 branches covered.">    if (storageItem.getHouseholdId() != householdId) {</span>
<span class="fc" id="L593">      throw new IllegalArgumentException(&quot;User is not allowed to update this item&quot;);</span>
    }
<span class="fc bfc" id="L595" title="All 2 branches covered.">    if (storageItem.isShared() == Boolean.TRUE.equals(request.getIsShared())) {</span>
<span class="fc" id="L596">      throw new IllegalArgumentException(&quot;Storage item already has the requested shared status&quot;);</span>
    }

<span class="fc" id="L599">    double quantityToMove = request.getQuantity();</span>
<span class="fc" id="L600">    double previousQuantity = storageItem.getQuantity();</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">    if (quantityToMove &gt; previousQuantity) {</span>
<span class="fc" id="L602">      throw new IllegalArgumentException(&quot;Cannot move more than the available quantity&quot;);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">    } else if (quantityToMove == previousQuantity) {</span>
<span class="fc" id="L604">      storageItem.setShared(request.getIsShared());</span>
<span class="fc" id="L605">      return convertToStorageItemResponses(List.of(storageItemRepo.update(storageItem)));</span>
    } else {
<span class="fc" id="L607">      StorageItem newStorageItem = new StorageItem();</span>
<span class="fc" id="L608">      newStorageItem.setExpirationDate(storageItem.getExpirationDate());</span>
<span class="fc" id="L609">      newStorageItem.setQuantity(previousQuantity - quantityToMove);</span>
<span class="fc" id="L610">      newStorageItem.setHouseholdId(storageItem.getHouseholdId());</span>
<span class="fc" id="L611">      newStorageItem.setItemId(storageItem.getItemId());</span>
<span class="fc" id="L612">      newStorageItem.setShared(storageItem.isShared());</span>

<span class="fc" id="L614">      storageItem.setQuantity(quantityToMove);</span>
<span class="fc" id="L615">      storageItem.setShared(request.getIsShared());</span>

<span class="fc" id="L617">      List&lt;StorageItem&gt; updatedItems = List.of(</span>
<span class="fc" id="L618">              storageItemRepo.update(storageItem),</span>
<span class="fc" id="L619">              storageItemRepo.add(newStorageItem)</span>
      );

<span class="fc" id="L622">      return convertToStorageItemResponses(updatedItems);</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>